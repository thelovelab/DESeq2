#' @rdname DESeqSummarizedExperiment
#' @export
setClass("DESeqSummarizedExperiment",
         contains = "SummarizedExperiment",
         representation = representation( 
           design = "formula",
           dispersionFunction = "function"))

setValidity( "DESeqSummarizedExperiment", function( object ) {
  if (! ("counts" %in% names(assays(object))))
    return( "the assays slot must contain a matrix named 'counts'" )
  if( !is.integer( counts(object) ) )
    return( "the count data is not in integer mode" )
  if( any( counts(object) < 0 ) )
    return( "the count data contains negative values" )
  if ( ncol(colData(object)) < 1 ) {
    return("colData must have at least one column")
  }
  design <- design(object)
  designVars <- all.vars(formula(design))
  if (!all(designVars %in% names(colData(object)))) {
    return("all variables in design formula must be columns in colData")
  }
  designVarsClass <- sapply(designVars, function(v) class(colData(object)[[v]]))
  designFactors <- designVars[designVarsClass == "factor"]
  if (any(sapply(designFactors,function(v) any(table(colData(object)[[v]]) == 0)))) {
    return("factors in design formula must have samples for each level")
  }
  modelMatrix <- model.matrix(design, data=as.data.frame(colData(object)))
  if (qr(modelMatrix)$rank < ncol(modelMatrix)) {
    return("the model matrix is not full rank, i.e. one or more variables in the design formula are linear combinations of the others")
  }
  TRUE
} )


#' DESeqSummarizedExperiment object and constructors
#'
#' The \code{DESeqSummarizedExperiment} is a subclass of \code{SummarizedExperiment},
#' used to store the input values, intermediate calculations and results of an
#' analysis of differential expression.  The \code{DESeqSummarizedExperiment} class
#' enforces non-negative integer values in the "counts" matrix stored as
#' the first element in the assay list.
#' In addition, a formula which specifies the design of the experiment must be provided.
#' The constructor functions create a DESeqSummarizedExperiment object
#' from various types of input:
#' a SummarizedExperiment, a matrix, or count files generated by
#' the python package HTSeq.  See the vignette for examples of construction
#' from all three input types.
#'
#' @param se a \code{SummarizedExperiment} with at least one column in colData,
#' and the counts as the first element in the assays list, which will be renamed
#' "counts".  A \code{SummarizedExperiment} object can be generated by the
#' function \code{summarizeOverlaps} in the GenomicRanges package.
#' @param design a formula which specifies the design of the experiment, taking the form
#' \code{formula(~ x + y + z)}.  By default, the functions in this package will use
#' the last variable in the formula (e.g. z) for presenting results (fold changes, etc.) and plotting.
#' @param countData for matrix input: a matrix of non-negative integers
#' @param colData for matrix input: a \code{DataFrame} or \code{data.frame} with at least a single column.
#' Rows of colData correspond to columns of countData.
#' @param sampleTable for htseq-count: a \code{data.frame} with three or more columns. Each row
#' describes one sample. The first column is the sample name, the second column
#' the file name of the count file generated by htseq-count, and the remaining
#' columns are sample metadata which will be stored in \code{colData}
#' @param directory for htseq-count: the directory relative to which the filenames are specified
#' @param ... arguments provided to \code{SummarizedExperiment} including rowData and exptData
#' 
#' @return A DESeqSummarizedExperiment object.
#' 
#' @aliases DESeqSummarizedExperiment DESeqSummarizedExperiment-class DESeqSummarizedExperimentFromMatrix DESeqSummarizedExperimentFromHTSeqCount
#'
#' @references See \url{http://www-huber.embl.de/users/anders/HTSeq} for htseq-count
#'
#' @docType class
#'
#' @examples
#'
#' countData <- matrix(1:4,ncol=2)
#' colData <- DataFrame(condition=factor(c("a","b")))
#' dse <- DESeqSummarizedExperimentFromMatrix(countData, colData, formula(~ condition))
#'
#' @rdname DESeqSummarizedExperiment
#' @export
DESeqSummarizedExperiment <- function(se, design) {
  if (names(assays(se))[1] != "counts") {
    message("renaming the first element in assays to 'counts'")
    names(assays(se))[1] <- "counts"
  }
  # before validity check, try to convert assay to integer mode
  if (any(assay(se) < 0)) {
    stop("some values in assay are negative")
  }
  if (any(round(assay(se)) != assay(se))) {
    stop("some values in assay are not integers")
  }  
  mode(assay(se)) <- "integer" 

  designVars <- all.vars(formula(design))
  designVarsClass <- sapply(designVars, function(v) class(colData(se)[[v]]))
  if (any(designVarsClass == "character")) {
    warning("some variables in design formula are characters, converting to factors")
    for (v in designVars[designVarsClass == "character"]) {
      colData(se)[[v]] <- factor(colData(se)[[v]])
    }
  }
  # add metadata columns on the columns
  mcolsCols <- DataFrame(type=rep("input",ncol(colData(se))),
                         description=rep("",ncol(colData(se))))
  if (is.null(mcols(colData(se)))) {
    mcols(colData(se)) <- mcolsCols
  } else {
    mcols(colData(se)) <- cbind(mcols(colData(se)), mcolsCols)
  }
  dse <- new("DESeqSummarizedExperiment", se, design = formula(design))
                                 
  # now we know we have at least an empty GRanges or GRangesList for rowData
  # so we can create a metadata column 'type' for the mcols
  # and we label any incoming columns as 'input'

  # this is metadata columns on the rows
  mcolsRows <- DataFrame(type=rep("input",ncol(mcols(dse))),
                         description=rep("",ncol(mcols(dse))))
  if (is.null(mcols(mcols(dse)))) {
    mcols(mcols(dse)) <- mcolsRows
  } else {
    mcols(mcols(dse)) <- cbind(mcols(mcols(dse)), mcolsRows)
  }
  return(dse)
}

#' @rdname DESeqSummarizedExperiment
#' @export
DESeqSummarizedExperimentFromMatrix <- function( countData, colData, design, ... )
{
  # we expect a matrix of counts, which are non-negative integers
  countData <- as.matrix( countData )
  if (is(colData,"data.frame")) colData <- DataFrame(colData, row.names=rownames(colData))
  se <- SummarizedExperiment(assays = SimpleList(counts=countData), colData = colData, ...)
  dse <- DESeqSummarizedExperiment(se, design = design)
  return(dse)
}

#' @rdname DESeqSummarizedExperiment
#' @export
DESeqSummarizedExperimentFromHTSeqCount <- function( sampleTable, directory="", design, ...) 
{
  if (missing(design)) {
    stop("design is missing")
  }
  l <- lapply( as.character( sampleTable[,2] ), function(fn) 
              read.table( file.path( directory, fn ) ) )
  if( ! all( sapply( l, function(a) all( a$V1 == l[[1]]$V1 ) ) ) )
    stop( "Gene IDs (first column) differ between files." )
  tbl <- sapply( l, function(a) a$V2 )
  rownames(tbl) <- l[[1]]$V1
  rownames(sampleTable) <- sampleTable[,1]
  specialRows <- rownames(tbl) %in% c( "no_feature", "ambiguous",
                                      "too_low_aQual", "not_aligned", "alignment_not_unique" )
  tbl <- tbl[ !specialRows, ]
  dse <- DESeqSummarizedExperimentFromMatrix(countData = tbl,
                                             colData = sampleTable[,-(1:2),drop=FALSE],
                                             design = design,
                                             ...)
  return(dse)
}   

